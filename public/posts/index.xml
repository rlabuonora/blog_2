
   <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
     <channel>
       <title>Posts on Rafael La Buonora</title>
       <link>/posts/</link>
       <description>Recent content in Posts on Rafael La Buonora</description>
       <generator>Hugo -- gohugo.io</generator>
       <copyright>Copyright &amp;copy; 2019 - Rafael La Buonora</copyright>
       <lastBuildDate>Wed, 01 Aug 2018 00:00:00 +0000</lastBuildDate>
       
           <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
       
       
       <item>
         <title>Scraping NBA data with rvest and purrr</title>
         <link>/posts/scraping-nba-data/</link>
         <pubDate>Wed, 01 Aug 2018 00:00:00 +0000</pubDate>
         
         <guid>/posts/scraping-nba-data/</guid>
         <description>


&lt;p&gt;The NBA does a great job releasing statistics on every aspect of the game. Most teams have analytics experts crunching those numbers for insights to get a competitive advantage.&lt;/p&gt;
&lt;p&gt;In this post I go through the process of scraping data from &lt;a href=&#34;https://www.basketball-reference.com/&#34;&gt;basketball-reference.com&lt;/a&gt; using the R package &lt;code&gt;rvest&lt;/code&gt;. We also do some data munging with &lt;code&gt;purrr&lt;/code&gt; and string interpolation with &lt;code&gt;glue&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;nba-reference&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;NBA Reference&lt;/h1&gt;
&lt;p&gt;This website has statistics on every aspect of the game for a long time. In this post, I’ll focus on individual player stats (Field Goal Percentage, Average Minutes, etc.) from the 2000/2001 season up to 2017/2018.&lt;/p&gt;
&lt;p&gt;If you follow &lt;a href=&#34;https://www.basketball-reference.com/leagues/NBA_2017_per_game.html&#34;&gt;this link&lt;/a&gt;, you can find the data for the 2017 season in an html table.&lt;/p&gt;
&lt;p&gt;Html uses a special markup language to format the tables so that your browser can render it properly. Typically, an html table has this structure:&lt;/p&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;&amp;lt;table&amp;gt;
  &amp;lt;th&amp;gt;Player&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;Data&amp;lt;td&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get this into an R data frame, you can use rvest. The first step is to get all the html from the page using read_html.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rvest)
nba_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/NBA_2017_per_game.html&amp;quot;
web_page &amp;lt;- read_html(nba_url)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to get the actual data from the table. &lt;code&gt;html_table&lt;/code&gt; does just that:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- html_table(web_page)
head(data[[1]])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Rk        Player Pos Age  Tm  G GS   MP  FG FGA  FG%  3P 3PA  3P%  2P
## 1  1  Álex Abrines  SG  23 OKC 68  6 15.5 2.0 5.0 .393 1.4 3.6 .381 0.6
## 2  2    Quincy Acy  PF  26 TOT 38  1 14.7 1.8 4.5 .412 1.0 2.4 .411 0.9
## 3  2    Quincy Acy  PF  26 DAL  6  0  8.0 0.8 2.8 .294 0.2 1.2 .143 0.7
## 4  2    Quincy Acy  PF  26 BRK 32  1 15.9 2.0 4.8 .425 1.1 2.6 .434 0.9
## 5  3  Steven Adams   C  23 OKC 80 80 29.9 4.7 8.2 .571 0.0 0.0 .000 4.7
## 6  4 Arron Afflalo  SG  31 SAC 61 45 25.9 3.0 6.9 .440 1.0 2.5 .411 2.0
##   2PA  2P% eFG%  FT FTA  FT% ORB DRB TRB AST STL BLK TOV  PF  PTS
## 1 1.4 .426 .531 0.6 0.7 .898 0.3 1.0 1.3 0.6 0.5 0.1 0.5 1.7  6.0
## 2 2.1 .413 .521 1.2 1.6 .750 0.5 2.5 3.0 0.5 0.4 0.4 0.6 1.8  5.8
## 3 1.7 .400 .324 0.3 0.5 .667 0.3 1.0 1.3 0.0 0.0 0.0 0.3 1.5  2.2
## 4 2.2 .414 .542 1.3 1.8 .754 0.6 2.8 3.3 0.6 0.4 0.5 0.6 1.8  6.5
## 5 8.2 .572 .571 2.0 3.2 .611 3.5 4.2 7.7 1.1 1.1 1.0 1.8 2.4 11.3
## 6 4.4 .457 .514 1.4 1.5 .892 0.1 1.9 2.0 1.3 0.3 0.1 0.7 1.7  8.4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That was easy! html_table returns a list with all the tables in the web_page as a data_frame. What we want is the first element of that list.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- data[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s inspect the data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    619 obs. of  30 variables:
##  $ Rk    : chr  &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;2&amp;quot; &amp;quot;2&amp;quot; ...
##  $ Player: chr  &amp;quot;Álex Abrines&amp;quot; &amp;quot;Quincy Acy&amp;quot; &amp;quot;Quincy Acy&amp;quot; &amp;quot;Quincy Acy&amp;quot; ...
##  $ Pos   : chr  &amp;quot;SG&amp;quot; &amp;quot;PF&amp;quot; &amp;quot;PF&amp;quot; &amp;quot;PF&amp;quot; ...
##  $ Age   : chr  &amp;quot;23&amp;quot; &amp;quot;26&amp;quot; &amp;quot;26&amp;quot; &amp;quot;26&amp;quot; ...
##  $ Tm    : chr  &amp;quot;OKC&amp;quot; &amp;quot;TOT&amp;quot; &amp;quot;DAL&amp;quot; &amp;quot;BRK&amp;quot; ...
##  $ G     : chr  &amp;quot;68&amp;quot; &amp;quot;38&amp;quot; &amp;quot;6&amp;quot; &amp;quot;32&amp;quot; ...
##  $ GS    : chr  &amp;quot;6&amp;quot; &amp;quot;1&amp;quot; &amp;quot;0&amp;quot; &amp;quot;1&amp;quot; ...
##  $ MP    : chr  &amp;quot;15.5&amp;quot; &amp;quot;14.7&amp;quot; &amp;quot;8.0&amp;quot; &amp;quot;15.9&amp;quot; ...
##  $ FG    : chr  &amp;quot;2.0&amp;quot; &amp;quot;1.8&amp;quot; &amp;quot;0.8&amp;quot; &amp;quot;2.0&amp;quot; ...
##  $ FGA   : chr  &amp;quot;5.0&amp;quot; &amp;quot;4.5&amp;quot; &amp;quot;2.8&amp;quot; &amp;quot;4.8&amp;quot; ...
##  $ FG%   : chr  &amp;quot;.393&amp;quot; &amp;quot;.412&amp;quot; &amp;quot;.294&amp;quot; &amp;quot;.425&amp;quot; ...
##  $ 3P    : chr  &amp;quot;1.4&amp;quot; &amp;quot;1.0&amp;quot; &amp;quot;0.2&amp;quot; &amp;quot;1.1&amp;quot; ...
##  $ 3PA   : chr  &amp;quot;3.6&amp;quot; &amp;quot;2.4&amp;quot; &amp;quot;1.2&amp;quot; &amp;quot;2.6&amp;quot; ...
##  $ 3P%   : chr  &amp;quot;.381&amp;quot; &amp;quot;.411&amp;quot; &amp;quot;.143&amp;quot; &amp;quot;.434&amp;quot; ...
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, so all the columns are read in as text. That’s natural, since all html pages are text, so we need to convert the data to the correct data types.&lt;/p&gt;
&lt;p&gt;Most columns seem to be &lt;code&gt;numeric&lt;/code&gt;, except &lt;code&gt;Player Name&lt;/code&gt; which is a &lt;code&gt;character&lt;/code&gt; vector, &lt;code&gt;Player Position&lt;/code&gt; and &lt;code&gt;Team&lt;/code&gt; which are &lt;code&gt;factors&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One approach to correcting the data types is to use dplyr’s mutate:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
data_1 &amp;lt;- data %&amp;gt;% 
  mutate(Rk = as.numeric(Rk),
         Pos = as.factor(Pos),
         Age = as.numeric(Age))
#       ...

str(select(data_1, Rk, Pos, Age))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    619 obs. of  3 variables:
##  $ Rk : num  1 2 2 2 3 4 5 6 7 8 ...
##  $ Pos: Factor w/ 7 levels &amp;quot;C&amp;quot;,&amp;quot;PF&amp;quot;,&amp;quot;PF-C&amp;quot;,..: 7 2 2 2 1 7 1 1 2 2 ...
##  $ Age: num  23 26 26 26 23 31 28 28 31 27 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But there’s a better way. &lt;code&gt;mutate_at&lt;/code&gt; applies a function to a list of columns.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_2 &amp;lt;- data %&amp;gt;% 
  mutate_at(vars(Tm, Pos), factor)

str(select(data_2, Tm, Pos))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    619 obs. of  2 variables:
##  $ Tm : Factor w/ 32 levels &amp;quot;ATL&amp;quot;,&amp;quot;BOS&amp;quot;,&amp;quot;BRK&amp;quot;,..: 21 30 7 3 21 26 19 18 27 12 ...
##  $ Pos: Factor w/ 7 levels &amp;quot;C&amp;quot;,&amp;quot;PF&amp;quot;,&amp;quot;PF-C&amp;quot;,..: 7 2 2 2 1 7 1 1 2 2 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Columns need to be specified as a list of variables: &lt;code&gt;vars(Tm, Pos)&lt;/code&gt;. In this case, the function applied is &lt;code&gt;factor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Repeat for all the numeric variables using the &lt;code&gt;:&lt;/code&gt; notation to select all the columns from &lt;code&gt;G&lt;/code&gt; to &lt;code&gt;PS.G&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_3 &amp;lt;- data %&amp;gt;%
  mutate_at(vars(G:`PTS`, Age), as.numeric)
str(select(data_3, G:`PTS`, Age))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    619 obs. of  26 variables:
##  $ G   : num  68 38 6 32 80 61 39 62 72 61 ...
##  $ GS  : num  6 1 0 1 80 45 15 0 72 5 ...
##  $ MP  : num  15.5 14.7 8 15.9 29.9 25.9 15 8.6 32.4 14.3 ...
##  $ FG  : num  2 1.8 0.8 2 4.7 3 2.3 0.7 6.9 1.3 ...
##  $ FGA : num  5 4.5 2.8 4.8 8.2 6.9 4.6 1.4 14.6 2.8 ...
##  $ FG% : num  0.393 0.412 0.294 0.425 0.571 0.44 0.5 0.523 0.477 0.458 ...
##  $ 3P  : num  1.4 1 0.2 1.1 0 1 0 0 0.3 0 ...
##  $ 3PA : num  3.6 2.4 1.2 2.6 0 2.5 0.1 0 0.8 0 ...
##  $ 3P% : num  0.381 0.411 0.143 0.434 0 0.411 0 NA 0.411 0 ...
##  $ 2P  : num  0.6 0.9 0.7 0.9 4.7 2 2.3 0.7 6.6 1.3 ...
##  $ 2PA : num  1.4 2.1 1.7 2.2 8.2 4.4 4.5 1.4 13.8 2.7 ...
##  $ 2P% : num  0.426 0.413 0.4 0.414 0.572 0.457 0.511 0.523 0.48 0.461 ...
##  $ eFG%: num  0.531 0.521 0.324 0.542 0.571 0.514 0.5 0.523 0.488 0.458 ...
##  $ FT  : num  0.6 1.2 0.3 1.3 2 1.4 0.7 0.2 3.1 0.4 ...
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But wait, what about the rest of the years? You probably heard about the DRY principe: Don’t Repeat Yourself. It’d be silly to write a whole script just to download data from another season, because most of the code would be the same. So we need to &lt;em&gt;reuse&lt;/em&gt; our code to get data from the rest of the seasons.&lt;/p&gt;
&lt;p&gt;To make our code more reusable, the first thing we need to do is build the url to get the html. We’ll use a super cool package called &lt;code&gt;glue&lt;/code&gt; for that.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(glue)
name &amp;lt;- &amp;quot;Rafa&amp;quot;
glue(&amp;quot;Hello, {name}&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Hello, Rafa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m sure you get the idea. It’s what programmer’s call &lt;em&gt;string interpolation&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For loops are used to &lt;em&gt;iterate&lt;/em&gt; over collections, so we can repeat some process without copying the code. With a for loop, we can generate a vector of urls for every season we’re interested in:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/&amp;quot;
page &amp;lt;- &amp;quot;NBA_{year}_per_game.html&amp;quot;
urls &amp;lt;- vector(&amp;quot;double&amp;quot;, length(2000:2017))
for (year in 2000:2017) {
  urls[[year-1999]] &amp;lt;- glue(base_url, page) ## year -1999 gives 1, 2, 3, ...
}
head(urls)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2000_per_game.html&amp;quot;
## [2] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2001_per_game.html&amp;quot;
## [3] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2002_per_game.html&amp;quot;
## [4] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2003_per_game.html&amp;quot;
## [5] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2004_per_game.html&amp;quot;
## [6] &amp;quot;https://www.basketball-reference.com/leagues/NBA_2005_per_game.html&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Awesome! Now instead of creating a vector of urls, we’ll create a list of data frames, one for every season.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/&amp;quot;
page &amp;lt;- &amp;quot;NBA_{year}_per_game.html&amp;quot;
data &amp;lt;- list()

for (year in 2015:2017) {
  nba_url &amp;lt;- glue(base_url, page) 
  web_page &amp;lt;- read_html(nba_url)
  data[[year-2014]] &amp;lt;- html_table(web_page)[[1]]

}
str(data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 3
##  $ :&amp;#39;data.frame&amp;#39;:    675 obs. of  30 variables:
##   ..$ Rk    : chr [1:675] &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; &amp;quot;4&amp;quot; ...
##   ..$ Player: chr [1:675] &amp;quot;Quincy Acy&amp;quot; &amp;quot;Jordan Adams&amp;quot; &amp;quot;Steven Adams&amp;quot; &amp;quot;Jeff Adrien&amp;quot; ...
##   ..$ Pos   : chr [1:675] &amp;quot;PF&amp;quot; &amp;quot;SG&amp;quot; &amp;quot;C&amp;quot; &amp;quot;PF&amp;quot; ...
##   ..$ Age   : chr [1:675] &amp;quot;24&amp;quot; &amp;quot;20&amp;quot; &amp;quot;21&amp;quot; &amp;quot;28&amp;quot; ...
##   ..$ Tm    : chr [1:675] &amp;quot;NYK&amp;quot; &amp;quot;MEM&amp;quot; &amp;quot;OKC&amp;quot; &amp;quot;MIN&amp;quot; ...
##   ..$ G     : chr [1:675] &amp;quot;68&amp;quot; &amp;quot;30&amp;quot; &amp;quot;70&amp;quot; &amp;quot;17&amp;quot; ...
##   ..$ GS    : chr [1:675] &amp;quot;22&amp;quot; &amp;quot;0&amp;quot; &amp;quot;67&amp;quot; &amp;quot;0&amp;quot; ...
##   ..$ MP    : chr [1:675] &amp;quot;18.9&amp;quot; &amp;quot;8.3&amp;quot; &amp;quot;25.3&amp;quot; &amp;quot;12.6&amp;quot; ...
##   ..$ FG    : chr [1:675] &amp;quot;2.2&amp;quot; &amp;quot;1.2&amp;quot; &amp;quot;3.1&amp;quot; &amp;quot;1.1&amp;quot; ...
##   ..$ FGA   : chr [1:675] &amp;quot;4.9&amp;quot; &amp;quot;2.9&amp;quot; &amp;quot;5.7&amp;quot; &amp;quot;2.6&amp;quot; ...
##   ..$ FG%   : chr [1:675] &amp;quot;.459&amp;quot; &amp;quot;.407&amp;quot; &amp;quot;.544&amp;quot; &amp;quot;.432&amp;quot; ...
##   ..$ 3P    : chr [1:675] &amp;quot;0.3&amp;quot; &amp;quot;0.3&amp;quot; &amp;quot;0.0&amp;quot; &amp;quot;0.0&amp;quot; ...
##   ..$ 3PA   : chr [1:675] &amp;quot;0.9&amp;quot; &amp;quot;0.8&amp;quot; &amp;quot;0.0&amp;quot; &amp;quot;0.0&amp;quot; ...
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;better-iteration-with-map&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Better iteration with map&lt;/h1&gt;
&lt;p&gt;Now our script does everything we want it to do. But there’s a wrinkle we have to iron out.&lt;/p&gt;
&lt;p&gt;A lot of programming is about iteration, and every programming language supports for loops. R has a great way to make iteration cleaner with the &lt;code&gt;purrr&lt;/code&gt; package. There’s a whole chapter on iteration in &lt;a href=&#34;http://r4ds.had.co.nz/iteration.html&#34;&gt;R for Data Science&lt;/a&gt;, which is a must read for anyone interested in R.&lt;/p&gt;
&lt;p&gt;Our script has to repeat the same steps for every year from 2000 to 2017. That’s a job for &lt;code&gt;map&lt;/code&gt;! &lt;code&gt;map&lt;/code&gt; takes a &lt;code&gt;list&lt;/code&gt; and applies a function to every element of the list.&lt;/p&gt;
&lt;p&gt;For example, here we apply the &lt;code&gt;head&lt;/code&gt; function to a list of data frames to get the first 6 lines of each one:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(mtcars, iris)
purrr::map(my_list, head)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
## 
## [[2]]
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of &lt;code&gt;head&lt;/code&gt;, which is a predefined function, you can use your own functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(mtcars, iris)
my_func &amp;lt;- function(data_frame) { print(&amp;quot;Hello from my fun!&amp;quot;)}
purrr::map(my_list, my_func)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello from my fun!&amp;quot;
## [1] &amp;quot;Hello from my fun!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;Hello from my fun!&amp;quot;
## 
## [[2]]
## [1] &amp;quot;Hello from my fun!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When applying map, you need to figure out our initial list to iterate over, and the function we want to apply to it’s elements in every iteration. The first part is easy, to get a list of seasons, we convert a numeric vector into a list like: &lt;code&gt;as.list(2000:2017)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we need a function that takes one year and does the job for that year. Something like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_player_data &amp;lt;- function(year) {
  base_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/&amp;quot;
  page &amp;lt;- &amp;quot;NBA_{year}_per_game.html&amp;quot;
  # Download data
  nba_url &amp;lt;- glue(base_url, page) 
  # extract the data frame from the table
  web_page &amp;lt;- read_html(nba_url)
  data &amp;lt;- html_table(web_page)[[1]]
  # return a data frame
  data
}

data.14 &amp;lt;- get_player_data(2014)
head(data.14)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Rk       Player Pos Age  Tm  G GS   MP  FG FGA  FG%  3P 3PA  3P%  2P 2PA
## 1  1   Quincy Acy  SF  23 TOT 63  0 13.4 1.0 2.2 .468 0.1 0.2 .267 1.0 2.0
## 2  1   Quincy Acy  SF  23 TOR  7  0  8.7 0.9 2.0 .429 0.3 0.7 .400 0.6 1.3
## 3  1   Quincy Acy  SF  23 SAC 56  0 14.0 1.1 2.3 .472 0.0 0.2 .200 1.0 2.1
## 4  2 Steven Adams   C  20 OKC 81 20 14.8 1.1 2.3 .503 0.0 0.0      1.1 2.3
## 5  3  Jeff Adrien  PF  27 TOT 53 12 18.1 2.7 5.2 .520 0.0 0.0      2.7 5.2
## 6  3  Jeff Adrien  PF  27 CHA 25  0 10.2 0.9 1.6 .550 0.0 0.0      0.9 1.6
##    2P% eFG%  FT FTA  FT% ORB DRB TRB AST STL BLK TOV  PF PTS
## 1 .492 .482 0.6 0.8 .660 1.1 2.3 3.4 0.4 0.4 0.4 0.5 1.9 2.7
## 2 .444 .500 0.7 1.1 .625 0.7 1.4 2.1 0.6 0.6 0.4 0.3 1.1 2.7
## 3 .496 .480 0.5 0.8 .667 1.2 2.4 3.6 0.4 0.3 0.4 0.5 2.0 2.7
## 4 .503 .503 1.0 1.7 .581 1.8 2.3 4.1 0.5 0.5 0.7 0.9 2.5 3.3
## 5 .520 .520 1.4 2.2 .639 1.9 3.8 5.8 0.7 0.5 0.7 0.7 2.0 6.8
## 6 .550 .550 0.5 1.0 .520 1.3 2.2 3.5 0.3 0.3 0.6 0.3 1.4 2.3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;pipes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Pipes&lt;/h1&gt;
&lt;p&gt;Pipes are a well known feature in the &lt;code&gt;tidyverse&lt;/code&gt;, so I won’t go into detail of how they work. We could turn our function into a set of pipes easily except for this line: &lt;code&gt;data &amp;lt;- html_table(web_page)[[1]]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We’re actually calling two functions in that line: &lt;code&gt;html_table&lt;/code&gt; with the &lt;code&gt;web_page&lt;/code&gt; argument and &lt;code&gt;[[&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; as an argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;web_page &amp;lt;- read_html(nba_url)
tbl_lst &amp;lt;- html_table(web_page)
df &amp;lt;- `[[`(tbl_lst, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can pipe it like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df_2 &amp;lt;- web_page %&amp;gt;% 
 html_table %&amp;gt;% 
 `[[`(1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we re-write our get_player_data function as:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_player_data &amp;lt;- function(year) {
  base_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/&amp;quot;
  page &amp;lt;- &amp;quot;NBA_{year}_per_game.html&amp;quot;
  
  glue(base_url, page) %&amp;gt;% 
    read_html %&amp;gt;% 
    html_table %&amp;gt;% 
    `[[`(1)
}

df.14 &amp;lt;- get_player_data(2014)
head(df.14)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Rk       Player Pos Age  Tm  G GS   MP  FG FGA  FG%  3P 3PA  3P%  2P 2PA
## 1  1   Quincy Acy  SF  23 TOT 63  0 13.4 1.0 2.2 .468 0.1 0.2 .267 1.0 2.0
## 2  1   Quincy Acy  SF  23 TOR  7  0  8.7 0.9 2.0 .429 0.3 0.7 .400 0.6 1.3
## 3  1   Quincy Acy  SF  23 SAC 56  0 14.0 1.1 2.3 .472 0.0 0.2 .200 1.0 2.1
## 4  2 Steven Adams   C  20 OKC 81 20 14.8 1.1 2.3 .503 0.0 0.0      1.1 2.3
## 5  3  Jeff Adrien  PF  27 TOT 53 12 18.1 2.7 5.2 .520 0.0 0.0      2.7 5.2
## 6  3  Jeff Adrien  PF  27 CHA 25  0 10.2 0.9 1.6 .550 0.0 0.0      0.9 1.6
##    2P% eFG%  FT FTA  FT% ORB DRB TRB AST STL BLK TOV  PF PTS
## 1 .492 .482 0.6 0.8 .660 1.1 2.3 3.4 0.4 0.4 0.4 0.5 1.9 2.7
## 2 .444 .500 0.7 1.1 .625 0.7 1.4 2.1 0.6 0.6 0.4 0.3 1.1 2.7
## 3 .496 .480 0.5 0.8 .667 1.2 2.4 3.6 0.4 0.3 0.4 0.5 2.0 2.7
## 4 .503 .503 1.0 1.7 .581 1.8 2.3 4.1 0.5 0.5 0.7 0.9 2.5 3.3
## 5 .520 .520 1.4 2.2 .639 1.9 3.8 5.8 0.7 0.5 0.7 0.7 2.0 6.8
## 6 .550 .550 0.5 1.0 .520 1.3 2.2 3.5 0.3 0.3 0.6 0.3 1.4 2.3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good, now we’re all set for using &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list_of_data_frames &amp;lt;- as.list(2000:2017) %&amp;gt;% 
  purrr::map(get_player_data)
  
str(list_of_data_frames)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 18
##  $ :&amp;#39;data.frame&amp;#39;:    517 obs. of  30 variables:
##   ..$ Rk    : chr [1:517] &amp;quot;1&amp;quot; &amp;quot;1&amp;quot; &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; ...
##   ..$ Player: chr [1:517] &amp;quot;Tariq Abdul-Wahad&amp;quot; &amp;quot;Tariq Abdul-Wahad&amp;quot; &amp;quot;Tariq Abdul-Wahad&amp;quot; &amp;quot;Shareef Abdur-Rahim&amp;quot; ...
##   ..$ Pos   : chr [1:517] &amp;quot;SG&amp;quot; &amp;quot;SG&amp;quot; &amp;quot;SG&amp;quot; &amp;quot;SF&amp;quot; ...
##   ..$ Age   : chr [1:517] &amp;quot;25&amp;quot; &amp;quot;25&amp;quot; &amp;quot;25&amp;quot; &amp;quot;23&amp;quot; ...
##   ..$ Tm    : chr [1:517] &amp;quot;TOT&amp;quot; &amp;quot;ORL&amp;quot; &amp;quot;DEN&amp;quot; &amp;quot;VAN&amp;quot; ...
##   ..$ G     : chr [1:517] &amp;quot;61&amp;quot; &amp;quot;46&amp;quot; &amp;quot;15&amp;quot; &amp;quot;82&amp;quot; ...
##   ..$ GS    : chr [1:517] &amp;quot;56&amp;quot; &amp;quot;46&amp;quot; &amp;quot;10&amp;quot; &amp;quot;82&amp;quot; ...
##   ..$ MP    : chr [1:517] &amp;quot;25.9&amp;quot; &amp;quot;26.2&amp;quot; &amp;quot;24.9&amp;quot; &amp;quot;39.3&amp;quot; ...
##   ..$ FG    : chr [1:517] &amp;quot;4.5&amp;quot; &amp;quot;4.8&amp;quot; &amp;quot;3.4&amp;quot; &amp;quot;7.2&amp;quot; ...
##   ..$ FGA   : chr [1:517] &amp;quot;10.6&amp;quot; &amp;quot;11.2&amp;quot; &amp;quot;8.7&amp;quot; &amp;quot;15.6&amp;quot; ...
##   ..$ FG%   : chr [1:517] &amp;quot;.424&amp;quot; &amp;quot;.433&amp;quot; &amp;quot;.389&amp;quot; &amp;quot;.465&amp;quot; ...
##   ..$ 3P    : chr [1:517] &amp;quot;0.0&amp;quot; &amp;quot;0.0&amp;quot; &amp;quot;0.1&amp;quot; &amp;quot;0.4&amp;quot; ...
##   ..$ 3PA   : chr [1:517] &amp;quot;0.4&amp;quot; &amp;quot;0.5&amp;quot; &amp;quot;0.1&amp;quot; &amp;quot;1.2&amp;quot; ...
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;another-functional-idiom-reduce&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Another functional idiom: Reduce&lt;/h1&gt;
&lt;p&gt;Map takes list and returns a list. In our script, it takes a list of numbers as input and returns a list of data frames. We now need to roll all those data frames into a single data frame.&lt;/p&gt;
&lt;p&gt;That’s what reduce does. It takes a list and applies a function to consequtive pairs. accumulating the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lst &amp;lt;- list(1, 2, 3, 4) 
purrr::reduce(lst, sum) # don&amp;#39;t do this in real life!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, since R’s sum is vectorized you don’t ever need to do that,&lt;/p&gt;
&lt;p&gt;Reduce works great with map:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lst &amp;lt;- list(1, 2, 3, 4) 
# Find the sum of the square root of 1, 2, 3, 4
purrr::map(lst, sqrt) %&amp;gt;% 
  purrr::reduce(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6.146264&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another example: get the sum of the rows in a list of data frames:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(mtcars, iris) %&amp;gt;% 
  purrr::map(nrow) %&amp;gt;% 
  purrr::reduce(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 182&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our case, what we need it to use &lt;code&gt;reduce&lt;/code&gt; with bind_rows, so we accumulate all the rows in our data_frame into a single one.&lt;/p&gt;
&lt;p&gt;Putting all the pieces together in the final script:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(glue)
library(purrr)
library(dplyr)
library(rvest)

# Download data table from basketball reference
get_player_data &amp;lt;- function(year) {
  
  base_nba_url &amp;lt;- &amp;quot;https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html&amp;quot;
  
  glue(base_nba_url) %&amp;gt;% 
    read_html() %&amp;gt;% 
    html_table() %&amp;gt;% 
    `[[`(1) %&amp;gt;% 
    mutate(Year = year)
}

data &amp;lt;- as.list(2000:2018) %&amp;gt;% 
  purrr::map(get_player_data) %&amp;gt;% 
  purrr::reduce(bind_rows) %&amp;gt;% 
  mutate_at(vars(G:`PS/G`, Age), as.numeric) %&amp;gt;% 
  mutate_at(vars(Tm, Pos), factor)

#saveRDS(data, file=&amp;quot;~/Desktop/data_science/nba_data_00_18.rds&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;what-to-do-with-the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What to do with the data&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fastbreakdata.com/classifying-the-modern-nba-player-with-machine-learning-539da03bb824&#34; class=&#34;uri&#34;&gt;https://fastbreakdata.com/classifying-the-modern-nba-player-with-machine-learning-539da03bb824&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/nba/comments/6pp8jo/ocrethinking_basketball_positions_with_machine/&#34; class=&#34;uri&#34;&gt;https://www.reddit.com/r/nba/comments/6pp8jo/ocrethinking_basketball_positions_with_machine/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://cs229.stanford.edu/proj2012/Wheeler-PredictingNBAPlayerPerformance.pdf&#34; class=&#34;uri&#34;&gt;http://cs229.stanford.edu/proj2012/Wheeler-PredictingNBAPlayerPerformance.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Effect of injury&lt;/li&gt;
&lt;li&gt;Regression candidates in a team&lt;/li&gt;
&lt;li&gt;PCA&lt;/li&gt;
&lt;li&gt;player stats predict team offense and defense rating?&lt;/li&gt;
&lt;li&gt;&lt;p&gt;predict wins based on offense and defense rating&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Mining Hamlet</title>
         <link>/posts/hamlet/</link>
         <pubDate>Sat, 20 Jan 2018 00:00:00 +0000</pubDate>
         
         <guid>/posts/hamlet/</guid>
         <description>


&lt;p&gt;A lot of Shakespeare’s tragic heores don’t dominate the first act of their plays. Instead, other characters speak about them, setting the scene for exploring their personalities as the play unfolds. This is the case of Julius Caesar, Macbeth and Othello (but not of King Lear).&lt;/p&gt;
&lt;p&gt;In this post I go over the text of Hamlet, Prince of Denmark, using the quantity of lines spoken by character to visualize the dynamic of the play. We’ll get the chance to use &lt;code&gt;dplyr&lt;/code&gt; and some &lt;code&gt;regular expressions&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;getting-the-text-of-the-plays&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Getting the text of the plays&lt;/h1&gt;
&lt;p&gt;The text of Shakespeare’s plays is available from the &lt;code&gt;gutenberg&lt;/code&gt; package. I downloaded the text and made it available as a data frame &lt;a href=&#34;../../public/data/shakespeare_plays.rds&#34;&gt;here&lt;/a&gt;
so you don’t have to.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;books &amp;lt;- readRDS(&amp;#39;../../public/data/shakespeare_plays.rds&amp;#39;)
hamlet &amp;lt;- books %&amp;gt;%  
  filter(title == &amp;quot;Hamlet, Prince of Denmark&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;extracting-the-character-names&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Extracting the Character names&lt;/h1&gt;
&lt;p&gt;We can use a regular expressions to extract character names from the lines of the play. Most characters names appear abreviated (Ham. for Hamlet, Hor. for Horatio).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lag&lt;/code&gt; and &lt;code&gt;cumsum&lt;/code&gt; are useful inside call to &lt;code&gt;mutate&lt;/code&gt; to look at consecutive lines in the data frame. I also create a line number index with &lt;code&gt;row_number&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Fran., Ham., Pol.
CHAR_REGEX &amp;lt;- regex(&amp;quot;^([A-Z][a-z]*)\\.&amp;quot;)
# Stage Dir
# [Enter Horatio and Marcellus.]
STAGEDIR_REGEX &amp;lt;- regex(&amp;quot;(\\[.+\\])&amp;quot;)

hamlet &amp;lt;- hamlet %&amp;gt;% 
  mutate(char_name = str_match(text, CHAR_REGEX)[,2]) %&amp;gt;% 
  mutate(stage_dir = str_match(text, STAGEDIR_REGEX)[,2],
         char_name = if_else(!is.na(stage_dir), &amp;quot;director&amp;quot;, char_name)) %&amp;gt;%
  mutate(start_speech = !is.na(char_name) &amp;amp; 
           lag(text) == &amp;quot;&amp;quot;) %&amp;gt;%
  mutate(speech_idx = cumsum(start_speech)) %&amp;gt;% 
  mutate(line = row_number()) %&amp;gt;% 
  select(text, char_name, start_speech, speech_idx, line)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to create a &lt;code&gt;data frame&lt;/code&gt; of speeches. Each line is a speech in the play, with the character that speaks it and the number of lines it lasts.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
# Build a df with speech, start line, length char
speeches_df &amp;lt;- hamlet %&amp;gt;% 
  group_by(speech_idx) %&amp;gt;% 
  summarise(char_name = first(char_name), 
            line = first(line),
          speech_length = as.integer(n()-2)) %&amp;gt;% 
  dplyr::filter(char_name != &amp;quot;director&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The longest speech is by Hamlet (duh!), and starts at line 2677.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;speeches_df %&amp;gt;% 
  arrange(-speech_length)
## # A tibble: 1,077 x 4
##    speech_idx char_name  line speech_length
##         &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;         &amp;lt;int&amp;gt;
##  1        498 Ham        2677            60
##  2        234 Ghost      1296            50
##  3         69 King        383            39
##  4        761 Ham        4039            36
##  5        154 Laer        846            35
##  6        522 Ham        2857            35
##  7        480 Pol        2553            34
##  8        479 Ham        2518            33
##  9        568 Ham        3139            32
## 10         84 King        502            31
## # … with 1,067 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets take a look at the text of the speech:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hamlet %&amp;gt;% 
  filter(line %in% 2677:2690) %&amp;gt;% 
  select(text) 
## # A tibble: 14 x 1
##    text                                           
##    &amp;lt;chr&amp;gt;                                          
##  1 Ham.                                           
##  2 Ay, so, God b&amp;#39; wi&amp;#39; ye!                         
##  3 Now I am alone.                                
##  4 O, what a rogue and peasant slave am I!        
##  5 Is it not monstrous that this player here,     
##  6 But in a fiction, in a dream of passion,       
##  7 Could force his soul so to his own conceit     
##  8 That from her working all his visage wan&amp;#39;d;    
##  9 Tears in his eyes, distraction in&amp;#39;s aspect,    
## 10 A broken voice, and his whole function suiting 
## 11 With forms to his conceit? And all for nothing!
## 12 For Hecuba?                                    
## 13 What&amp;#39;s Hecuba to him, or he to Hecuba,         
## 14 That he should weep for her? What would he do,&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets focus on the characters with the most lines:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;top_speakers &amp;lt;- speeches_df %&amp;gt;% 
  group_by(char_name)  %&amp;gt;%
  summarize(total_lines = sum(speech_length)) %&amp;gt;% 
  arrange(-total_lines) %&amp;gt;% 
  head(6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use &lt;code&gt;inner_join&lt;/code&gt; to discard the less important characters:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Keep speeches by these speakers
speeches_df_main &amp;lt;- speeches_df %&amp;gt;% 
  inner_join(top_speakers, by = &amp;quot;char_name&amp;quot;) %&amp;gt;% 
  filter(!is.na(char_name))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last thing we need is a column with the cumulative lines spoken by each character:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;speeches_df_main &amp;lt;- speeches_df_main %&amp;gt;% 
   group_by(char_name) %&amp;gt;% 
   mutate(cum_lines = as.integer(cumsum(speech_length))) %&amp;gt;% 
   ungroup() %&amp;gt;% 
   mutate(char_name = fct_recode(char_name,
             &amp;quot;Horatio&amp;quot;       = &amp;quot;Hor&amp;quot;,
             &amp;quot;King Claudius&amp;quot; = &amp;quot;King&amp;quot;,
             &amp;quot;Laertes&amp;quot;       = &amp;quot;Laer&amp;quot;,
             &amp;quot;Polonius&amp;quot;      = &amp;quot;Pol&amp;quot;,
             &amp;quot;Ophelia&amp;quot;       = &amp;quot;Oph&amp;quot;,
             &amp;quot;Hamlet&amp;quot;        = &amp;quot;Ham&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can plot the play:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# color palette
col.pal &amp;lt;- RColorBrewer::brewer.pal(8, &amp;quot;Set2&amp;quot;)

# Plot Play
g &amp;lt;- ggplot(speeches_df_main, aes(line, cum_lines, fill = char_name)) + 
  guides(colour = guide_legend(title = NULL)) +
  geom_area(alpha = 0.8) + 
  guides(fill = guide_legend(title = NULL)) +
  scale_fill_brewer(palette = &amp;quot;Set2&amp;quot;) + 
  labs(title = &amp;quot;Cumulative lines&amp;quot;, subtitle = &amp;quot;By Character&amp;quot;) + 
  xlab(&amp;quot;Line&amp;quot;) + 
  ylab(&amp;quot;Spoken Lines&amp;quot;) +
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        panel.border = element_blank()) +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0))

g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-08-20-hamlet_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The plot shows the dynamic of the play quite nicely. Horatio, Hamlet’s friend figures quite prominenty at the beggining. Polonius has a lot of lines in the middle of the play, until he’s caught behind the arras just before line 4000. Towards the end, Hamlet eats up the whole play in his showdown with King Claudius.&lt;/p&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Tidy Vargas Llosa</title>
         <link>/posts/tidy-vargas-llosa/</link>
         <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
         
         <guid>/posts/tidy-vargas-llosa/</guid>
         <description>


&lt;p&gt;Mario Vargas Llosa es uno de mis novelistas preferidos. El año pasado releí varios de sus libros y escribí &lt;a href=&#34;https://rlabuonora74.wordpress.com/&#34;&gt;algunos reviews&lt;/a&gt;. En este post aplico algunas de las técnicas de &lt;a href=&#34;https://www.tidytextmining.com/&#34;&gt;este libro&lt;/a&gt; a las novelas.&lt;/p&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Datos&lt;/h1&gt;
&lt;p&gt;Para este proyecto, conseguí todas las novelas de Vargas Llosa en Inglés en formato digital (epub, mobi) y las convertí a texto.&lt;/p&gt;
&lt;p&gt;El primer paso para analizar texto es estructurarlo para el análisis. Este proceso se llama tokenización, porque implica separar el texto en “tokens”, pequeñas unidades de análisis. En este caso vamos a trabajar con texto tokenizado en palabras. El proceso de tokenización también puede incluír convertir las palabras a minúsculas y sacar las puntuaciones.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wordcloud&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Wordcloud&lt;/h1&gt;
&lt;p&gt;El análisis más básico de texto on R se llama WordCloud, y grafica las palabras más usadas en el texto analizando con el tamaño de la fuente proporcional a la frecuencia en que aparecen los términos.&lt;/p&gt;
&lt;p&gt;Para hacer un WordCloud para una novela concreta, filtramos el data frame para que tenga solo el texto de la novela, y usamos &lt;code&gt;anti_join&lt;/code&gt; para sacar las stop words. Las &lt;code&gt;stop words&lt;/code&gt; son palabras como “la” y “de”. Suelen ser las palabras más usadas, pero no tienen información sobre el contenido del texto, por lo que es conveniente sacarlas.&lt;/p&gt;
&lt;p&gt;Los otros tokens que llaman la atención en este análisis son los nombres de los personajes. Rigoberto y Lucrecia son los tokens más usados en Los cuadernos de don Rigoberto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- mvll_tidy %&amp;gt;% 
  filter(title == &amp;quot;Notebooks of Don Rigoberto&amp;quot; ) %&amp;gt;%
  filter(!str_detect(word, &amp;quot;\u2019&amp;quot;)) %&amp;gt;% # remove didn&amp;#39;t, they&amp;#39;re, etc.
  anti_join(stop_words) %&amp;gt;%
  count(word, sort = TRUE) %&amp;gt;% 
  with(wordcloud(word, n, max.words = 40))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-11-20-tidy-vargas-llosa_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;palabras-caracteristicas-de-cada-libro&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Palabras características de cada libro&lt;/h1&gt;
&lt;p&gt;Otro análisis similar es el índice de tf-idf. Esta métrica busca extraer los términos más característicos de un texto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;book_words &amp;lt;- mvll_tidy %&amp;gt;%
  count(title, word, sort = TRUE) %&amp;gt;%
  ungroup %&amp;gt;%
  bind_tf_idf(word, title, n)

plt &amp;lt;- book_words %&amp;gt;%
  arrange(desc(tf_idf)) %&amp;gt;%
  mutate(word = factor(word, levels = rev(unique(word))))



plt %&amp;gt;%
  filter(title %in% libros$title[10:13]) %&amp;gt;%
  group_by(title) %&amp;gt;%
  top_n(10) %&amp;gt;%
  ungroup %&amp;gt;%
  ggplot(aes(word, tf_idf, fill = title)) +
  geom_col(show.legend = FALSE) +
  labs(x = NULL, y = &amp;quot;tf-idf&amp;quot;) + 
  facet_wrap(~title, ncol = 2, scales=&amp;quot;free&amp;quot;) + 
  coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-11-20-tidy-vargas-llosa_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;sentiment-analysis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Sentiment Analysis&lt;/h1&gt;
&lt;p&gt;El análisis de sentimiento busca crear métricas para que tan positivo o negativo es el texto que estamos analizando. Para eso, necesitamos un “léxico”, una base de datos con palabras y sus sentimientos correspondientes. Bing es uno de los léxicos disponibles, y para cada palabra define si es positivo o negativo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(get_sentiments(&amp;quot;bing&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##   word       sentiment
##   &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;    
## 1 2-faces    negative 
## 2 abnormal   negative 
## 3 abolish    negative 
## 4 abominable negative 
## 5 abominably negative 
## 6 abominate  negative&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para analizar el texto de las novelas, usamos el léxico para determinar si cada palabra es positiva o negativa. Después tomamos unidades de 80 líneas y calculamos &lt;code&gt;sentiment&lt;/code&gt; como la diferencia entre la cantidad de palabras positivas y negativas. Esto nos da una métrica de que tan positivas son las palabras usadas en esa parte del texto.&lt;/p&gt;
&lt;p&gt;La columna &lt;code&gt;idx&lt;/code&gt; son bloques de 80 líneas y sirven para encontrar pasajes en las novelas después de visualizarlas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mvll_sentiment &amp;lt;- mvll_tidy %&amp;gt;% 
   filter(title %in% c(&amp;quot;Aunt Julia and the Scriptwriter&amp;quot;,
                       &amp;quot;Conversation in the Cathedral&amp;quot;,
                       &amp;quot;A Fish in the Water&amp;quot;,
                       &amp;quot;Feast of the Goat&amp;quot;,
                       &amp;quot;Notebooks of Don Rigoberto&amp;quot;,
                       &amp;quot;Bad Girl&amp;quot;)) %&amp;gt;%
  inner_join(get_sentiments(&amp;quot;bing&amp;quot;)) %&amp;gt;% 
  count(title, index = line %/% 80, sentiment) %&amp;gt;%
  spread(sentiment, n) %&amp;gt;%
  mutate(sentiment = positive - negative)


ggplot(mvll_sentiment, aes(index, sentiment, fill=title)) + 
  geom_col() + 
  facet_wrap(~title, ncol = 2, scales = &amp;quot;free_x&amp;quot;) + 
  guides(fill=FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-11-20-tidy-vargas-llosa_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;En general, Vargas Llosa usa pocas palabras con sentimientos positivos. Esta visualización también identifica momentos particularmente buenos o malos en las novelas: en la mitad de los Cuadernos de don Rigoberto hay una parte que destaca como buena.&lt;/p&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Geometría con ggplot</title>
         <link>/posts/ggplot-geometria/</link>
         <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
         
         <guid>/posts/ggplot-geometria/</guid>
         <description>


&lt;p&gt;&lt;code&gt;ggplot&lt;/code&gt; es el estándar para visualización de datos en R. Siempre quise explorar si podía servir para hacer diagramas más conceptuales. En este post uso &lt;code&gt;ggplot&lt;/code&gt; para dibujar algunas formas geométricas.&lt;/p&gt;
&lt;p&gt;Para dibujar el gráfico de una función, podemos usar &lt;code&gt;stat_function&lt;/code&gt;. En el primer gráfico, dibujo &lt;span class=&#34;math inline&#34;&gt;\(sin(x)\)&lt;/span&gt; y &lt;span class=&#34;math inline&#34;&gt;\(cos(x)\)&lt;/span&gt;. Especifico &lt;code&gt;aes(colour = &amp;quot;sin(x)&amp;quot;)&lt;/code&gt; para que el color de ese cada &lt;code&gt;geom&lt;/code&gt; quede ligado al texto correcto en la leyenda.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geom_segment&lt;/code&gt; y &lt;code&gt;scale_x_continuous&lt;/code&gt; permiten especificar la posición y etiqueta de las guías.&lt;/p&gt;
&lt;p&gt;Este post de stackoverflow sobre &lt;a href=&#34;https://stackoverflow.com/questions/5293715/how-to-use-greek-symbols-in-ggplot2&#34;&gt;como poner letras griegas en ggplot&lt;/a&gt; explica como poner caractéres del alfabeto griego en los ejes usando &lt;code&gt;expression()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(ggplot2)
theme_set(theme_minimal())

# Crear etiquetas para eje x
lbls &amp;lt;- c( expression(-2 * pi),
           expression(-3 * pi / 2),
           expression(- pi),
           expression(-pi/2),
           0,
           expression(pi/ 2),
           expression(pi),
           expression(3 * pi /2),
           expression(2 * pi)
           )


# Gráfico
ggplot(data_frame(x = c(-7, 7)), aes(x = x)) +
  stat_function(fun = function(x) { sin(x) }, 
                geom = &amp;quot;line&amp;quot;, 
                linetype = &amp;quot;dashed&amp;quot;, 
                size = 1,
                aes(colour = &amp;quot;sin(x)&amp;quot;)) +
  stat_function(fun = function(x) { cos(x) },
                linetype = &amp;quot;dashed&amp;quot;,
                size = 1,
                aes(colour = &amp;quot;cos(x)&amp;quot;)
                ) +
  scale_x_continuous(
    breaks = seq(-2 * pi, 2*pi, pi/2),
    labels = lbls
  ) + 
  labs(x = &amp;quot;x&amp;quot;, y = &amp;quot;y&amp;quot;) + 
  geom_segment(aes(x=-7, xend = 7, y=0, yend=0), 
               size = 0.5,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + 
  geom_segment(aes(x=0, xend=0, y=-1, yend=1.2),
               size = 0.5,
               lineend = &amp;quot;butt&amp;quot;,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + 
  labs(title = &amp;quot;Funciones Trigonométricas&amp;quot;) + 
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_blank(),
  ) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-08-16-trigonometric-funs_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;circulo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Círculo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat_fun&lt;/code&gt; resuelve el problema de graficar funciones, pero no sirve cuando queremos graficar otro tipo de objeto. La ecuación de un círculo es&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (x-h)^2+(y-k)^2=r^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;donde &lt;span class=&#34;math inline&#34;&gt;\((h, k)\)&lt;/span&gt; es el centro y &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; el radio. Escribir esta ecuación explícitamente como una función puede resultar complicado.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2&#34;&gt;Este post en Stack Overflow&lt;/a&gt; explica como graficar una función en forma paramétrica usando &lt;code&gt;annotate&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(latex2exp)

center &amp;lt;- c(x=3, y=1)
#pt1 &amp;lt;- c(x=1, y=1)
#pt2 &amp;lt;- c(x=5, y=1)
pt3 &amp;lt;- c(x=3, y=3)
pt4 &amp;lt;- c(x=3, y=-1)
pts &amp;lt;- dplyr::bind_rows(center,pt3, pt4)
radius &amp;lt;- 2
t &amp;lt;- seq(0, 2*pi, length.out = 100)

g &amp;lt;- ggplot() + 
  geom_segment(aes(x=-1, xend = 6, y=0, yend=0),
               size = 0.5,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + # Eje X
  geom_segment(aes(x=0, xend=0, y=-1, yend=4),
               size = 0.5,
               lineend = &amp;quot;butt&amp;quot;,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + # Eje Y
  annotate(&amp;quot;path&amp;quot;, 
           x = center[1] + radius * cos(t),
           y = center[2] + radius * sin(t)) + 
  geom_point(data = pts, aes(x=x, y =y)) + 
  geom_text(data = pts,
            parse = TRUE,
            nudge_y = 0.2,
            aes(x=x, y=y, label = paste0(&amp;quot;list(&amp;quot;, x ,&amp;quot;,&amp;quot;, y, &amp;quot;)&amp;quot;))) +
  annotate(&amp;quot;point&amp;quot;, x=1, y=1) + 
  annotate(&amp;quot;text&amp;quot;, x=1.25, y=1, label=&amp;quot;1,1&amp;quot;) + 
  annotate(&amp;quot;point&amp;quot;, x=5, y=1) + 
  annotate(&amp;quot;text&amp;quot;, x=4.75, y=1, label=&amp;quot;5, 1&amp;quot;) + 
  labs(x=&amp;quot;&amp;quot;, y=&amp;quot;&amp;quot;) + 
  ggtitle(TeX(&amp;quot;(x-3)^2+(y-1)^2=4&amp;quot;)) + 
  coord_fixed()
g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-08-16-trigonometric-funs_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;parabola&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Parábola&lt;/h2&gt;
&lt;p&gt;Una parábola es un conjunto de puntos que equidista de una línea (directriz) y un punto (foco). Estos puntos satisfacen:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\((x-h)^2=4p(y-k),\, (p \neq 0)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;El vértice de la parábola está en &lt;span class=&#34;math inline&#34;&gt;\((h,k)\)&lt;/span&gt; y la directriz &lt;span class=&#34;math inline&#34;&gt;\(y=k-p\)&lt;/span&gt;. El foco está en &lt;span class=&#34;math inline&#34;&gt;\((h, k+p)\)&lt;/span&gt; si la parábola es abierta hacia arriba.&lt;/p&gt;
&lt;div id=&#34;ejemplo&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Ejemplo&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x^2=16y\)&lt;/span&gt; es una parábola con vértice en &lt;span class=&#34;math inline&#34;&gt;\((0,0)\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(p = 4\)&lt;/span&gt; y foco en &lt;span class=&#34;math inline&#34;&gt;\((0,4)\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;focus &amp;lt;- list(x=0, y=4, lab = &amp;quot;Foco&amp;quot;)
vertex &amp;lt;- list(x=0, y=0, lab = &amp;quot;Vértice&amp;quot;)
notable_points &amp;lt;- bind_rows(focus, 
                            vertex)
pt &amp;lt;- data_frame(x=5, y=round(5^2/16, 2))

p &amp;lt;- ggplot(data_frame(x=0), aes(x=x)) +
  geom_segment(aes(x=-9, xend = 9, y=0, yend=0),
               size = 0.5,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + # Eje X
  geom_segment(aes(x=0, xend=0, y=-5, yend=10),
               size = 0.5,
               lineend = &amp;quot;butt&amp;quot;,
               arrow = arrow(length = unit(0.2, &amp;quot;cm&amp;quot;))) + # Eje Y
  stat_function(fun = function(x) { x^2 / 16}) + 
  xlim(-9, 9) + 
  ylim(-5, 10)

x &amp;lt;- 5

g_2 &amp;lt;- p +
  geom_point(data = notable_points, aes(x=x, y=y)) + 
  geom_text(data=notable_points, 
            size = 3,
            nudge_y = 1.25,
            nudge_x = 1.25,
            aes(label = paste0(lab, &amp;quot;\n(&amp;quot;, x, &amp;quot;,&amp;quot;, y, &amp;quot;)&amp;quot;), 
                x = x, y = y)) + 
  geom_hline(yintercept = -4, linetype = &amp;quot;dashed&amp;quot;) + 
  annotate(&amp;quot;text&amp;quot;, x= 3, y= -3.3, label = &amp;quot;Directriz&amp;quot;, size = 3) +
  ggtitle(TeX(&amp;#39;$y=x^2/16$&amp;#39;)) + 
  theme(
    plot.title = element_text(hjust = 0.5)
  ) + geom_point(data = pt, aes(x=x, y=y)) + 
  geom_segment(aes(x= focus$x, y=focus$y, xend=pt$x, yend=pt$y),
               linetype = &amp;quot;dashed&amp;quot;) + 
  geom_segment(aes(x=pt$x, y=pt$y, xend=pt$x, yend = -4),
               linetype = &amp;quot;dashed&amp;quot;) + 
  annotate(&amp;quot;text&amp;quot;, 
           label = &amp;quot;phantom(0) == phantom(0)&amp;quot;, 
           parse = TRUE,
           angle = 60,
           size = 5,
           x = 2.5, y= 2.85) + 
  annotate(&amp;quot;text&amp;quot;, 
           label = &amp;quot;phantom(0) == phantom(0)&amp;quot;, 
           parse = TRUE,
           size = 5,
           x = 5, y= -2)
g_2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-08-16-trigonometric-funs_files/figure-html/g_2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Todos los puntos de la parábola estan a la misma distancia del foco que de la directriz.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;una-parabola-con-eje-horziontal&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Una parábola con eje horziontal&lt;/h2&gt;
&lt;p&gt;Dibujar una parábola con eje vertical es simple porque podemos usar &lt;code&gt;stat_fun&lt;/code&gt;. Pero si queremos dibujarlas con eje horizontal no podemos escibir los puntos de la parábola como un función y pasarsela a &lt;code&gt;stat_function&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La ecuación &lt;span class=&#34;math inline&#34;&gt;\(y^2+6y+8x+25 = 0\)&lt;/span&gt; no parece una parábola, pero si completamos el cuadrado:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
y^2+6y+8x+25 &amp;amp;= 0\\
y^2+6y+9+8x+25-9  &amp;amp;= 0\\
(y+3)^2 &amp;amp;= -16-8x\\
(y+3)^2 &amp;amp;= 4(-2)(x+2)
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Es una parábola con vértice &lt;span class=&#34;math inline&#34;&gt;\((-2, -3)\)&lt;/span&gt;, p es &lt;span class=&#34;math inline&#34;&gt;\(-2\)&lt;/span&gt;, el foco &lt;span class=&#34;math inline&#34;&gt;\((-4,-3)\)&lt;/span&gt; la directriz es &lt;span class=&#34;math inline&#34;&gt;\(x=0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Pero como la orientación de esta parábola es horizontal, no es una función. Cómo la graficamos con &lt;code&gt;ggplot&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Si despejamos &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; en función de &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;, obtenemos dos funciones:
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
(y+3)^2 &amp;amp;= (-8)(x+2)\\
y     &amp;amp;= -3 \pm \sqrt{-8(x+2)}\\
y_1  &amp;amp;=-3 + \sqrt{-8(x+2)}\\
y_2 &amp;amp;=-3 - \sqrt{-8(x+2)}\\
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Podemos graficar &lt;span class=&#34;math inline&#34;&gt;\(y1\)&lt;/span&gt; y &lt;span class=&#34;math inline&#34;&gt;\(y2\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- seq(-5, 0, length.out=1e3)
lbs &amp;lt;- list(bquote(-3 + sqrt(-8*(x+2))), # investigar bquote!
            bquote(-3 - sqrt(-8*(x+2))))

g_3 &amp;lt;- ggplot(data_frame(x=x), 
            aes(x=x, color = color)) + 
  stat_function(data = data_frame(x=x, color = factor(1)),
                fun = function(x) { -3 + sqrt(-8*(x+2)) }) + 
  stat_function(data = data_frame(x=x, color = factor(2)),
                fun = function(x) { -3 - sqrt(-8*(x+2)) }) + 
  scale_color_manual(labels = lbs,
                     name = &amp;quot;&amp;quot;,
                     values = c(scales::hue_pal()(2)[1], 
                                scales::hue_pal()(2)[2])) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0)
g_3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/posts/2018-08-16-trigonometric-funs_files/figure-html/g_3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
       </item>
       
     </channel>
   </rss>

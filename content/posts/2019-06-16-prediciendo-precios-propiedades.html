---
title: Prediciendo Precios de Propiedades con scikit-learn
author: Rafa
date: '2019-06-16'
slug: predicting-house-prices
categories: []
tags: ["python", "scikit-learn"]
---



<p>En este post armo un modelo de regresión para predecir el precio de venta de una propiedad inmobiliaria. Las columnas disponibles incluyen 80 columnas con información sobre la localización de las propiedades, su estructura y estado de conservación, su localización y la fecha y condiciones de la venta.</p>
<p>En la primera parte importo y describo las columnas disponibles, identifico outliers en algunas variables importantes e implemento algunas correcciones.</p>
<p>Luego estimo tres modelos para predecir la variable objetivo: el precio de venta de la propiedad. Dado que la variables es continua, uso 3 modelos de regresión: regresión lineal sin regularización, regresión Ridge y regresión Lasso.</p>
<p>En la última parte analizo la performance del modelo y algunas posibles líneas para mejorarlo.</p>
<pre class="python"><code># Importar módulos
import pandas as pd
import numpy as np
# Leer los datos 
casas = pd.read_csv(&quot;../../public/data/precios_casas/train.csv&quot;)

# Primeras filas
print(casas.head())</code></pre>
<pre><code>##    Id  MSSubClass MSZoning  ...  SaleType  SaleCondition SalePrice
## 0   1          60       RL  ...        WD         Normal    208500
## 1   2          20       RL  ...        WD         Normal    181500
## 2   3          60       RL  ...        WD         Normal    223500
## 3   4          70       RL  ...        WD        Abnorml    140000
## 4   5          60       RL  ...        WD         Normal    250000
## 
## [5 rows x 81 columns]</code></pre>
<p>Cantidad de filas y columnas:</p>
<pre class="python"><code>print(casas.shape)</code></pre>
<pre><code>## (1460, 81)</code></pre>
<p>Columnas con datos faltantes</p>
<pre class="python"><code>print(casas.isnull().any().sum())</code></pre>
<pre><code>## 19</code></pre>
<p>Columnas numéricas con datos faltantes:</p>
<pre class="python"><code># Seleccionar numéricas
numericas = casas.select_dtypes(include = [np.number])
# Columnas numéricas con faltantes
print(casas[numericas.columns[numericas.isnull().any()]].isnull().sum().sort_values(ascending = False))</code></pre>
<pre><code>## LotFrontage    259
## GarageYrBlt     81
## MasVnrArea       8
## dtype: int64</code></pre>
<pre class="python"><code># Columnas categóricas
categoricas = casas.select_dtypes(include=[object])

# Columnas categóricas con faltantes
print(casas[categoricas.columns[categoricas.isnull().any()]].isnull().sum().sort_values(ascending = False))</code></pre>
<pre><code>## PoolQC          1453
## MiscFeature     1406
## Alley           1369
## Fence           1179
## FireplaceQu      690
## GarageCond        81
## GarageQual        81
## GarageFinish      81
## GarageType        81
## BsmtFinType2      38
## BsmtExposure      38
## BsmtFinType1      37
## BsmtCond          37
## BsmtQual          37
## MasVnrType         8
## Electrical         1
## dtype: int64</code></pre>
<div id="variable-objetivo-saleprice" class="section level1">
<h1>Variable objetivo: SalePrice</h1>
<p>Es el precio de venta de la propiedad. Es continua y no tiene missings. La propiedad promedio se vendió en $ 180.920, la más barata salió $ 34.900 y la más cara $755.000. Tiene distribución asimétrica, con la cola larga a la derecha (es más probable que una casa sea más cara que más barata que el promedio). Esta asimetría hace que sea conveniente normalizarla para modelarla.</p>
<pre class="python"><code>casas[[&quot;SalePrice&quot;]].describe()</code></pre>
<pre><code>##            SalePrice
## count    1460.000000
## mean   180921.195890
## std     79442.502883
## min     34900.000000
## 25%    129975.000000
## 50%    163000.000000
## 75%    214000.000000
## max    755000.000000</code></pre>
<pre class="python"><code>def helper_curtosis(x):
  # Texto sobre la curtosis de x
  # para agregar al gráfico
  sk = skew(x)
  sk_pval = skewtest(x)[0]
  return f&#39;Curtosis:\n{sk:.2f} ({sk_pval:.3f})&#39;</code></pre>
<p>Es asimética:</p>
<pre class="python"><code>import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
from scipy.stats import skew, skewtest

fig, ax = plt.subplots(1, 2, figsize=(12,4))

# SalePrice sin transformar
x = casas[&quot;SalePrice&quot;]
sns.distplot(x, kde=False, fit=stats.norm, ax=ax[0])
ax[0].text(400000, 0.000005, helper_curtosis(x), fontsize = 14)
#ax[0].set_title(&quot;SalePrice&quot;)

# SalePrice transformada
log1_x = np.log1p(casas[&quot;SalePrice&quot;])
sns.distplot(log1_x, kde=False, fit=stats.norm, ax=ax[1])
ax[1].text(12.6, 0.6, helper_curtosis(log1_x), fontsize = 14)
ax[1].set_xlabel(&quot;log(1+SalePrice)&quot;)

_ = fig.suptitle(&quot;La transformación x = log(1+x) corrige la asimetría en SalePrice&quot;, fontsize=16)</code></pre>
<p><img src="/posts/2019-06-16-prediciendo-precios-propiedades_files/figure-html/unnamed-chunk-8-1.png" width="1152" />
El <a href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.stats.skewtest.html#scipy.stats.skewtest">test de curtosis</a> es una prueba estadística para determinar si la distibución es simétrica. En la variable original rechazamos que la distribución sea simétrica y en la transformada con <code>log(1+x)</code> no rechazamos la hipótesis nula de que la distribución es simétrica.</p>
<div id="correlaciones-con-otras-columnas" class="section level2">
<h2>Correlaciones con otras columnas</h2>
<pre class="python"><code># Correlaciones con SalePrice
corr_sales_price = casas.corr()[&quot;SalePrice&quot;]

# Solo las mayores que 0.63 ordenadas descendiendo
corrs_altas = corr_sales_price[corr_sales_price &gt; 0.4].sort_values(ascending = False)
print(corrs_altas)</code></pre>
<pre><code>## SalePrice       1.000000
## OverallQual     0.790982
## GrLivArea       0.708624
## GarageCars      0.640409
## GarageArea      0.623431
## TotalBsmtSF     0.613581
## 1stFlrSF        0.605852
## FullBath        0.560664
## TotRmsAbvGrd    0.533723
## YearBuilt       0.522897
## YearRemodAdd    0.507101
## GarageYrBlt     0.486362
## MasVnrArea      0.477493
## Fireplaces      0.466929
## Name: SalePrice, dtype: float64</code></pre>
<p>Calculamos las correlaciones de la variables objetivo con el resto de las variables para determinar en qué variables enfocarnos:</p>
<p>La calidad de la casa (<code>OverallQual</code>), el metraje (<code>GrLivArea</code>), la cantidad de autos que entran en el garage (<code>GarageCars</code>) y el metraje del garage (<code>GarageArea</code>) son las variables continuas más importantes.</p>
<pre class="python"><code># Marcar outlier
casas[&quot;outlier&quot;] = np.logical_and(casas[&quot;GrLivArea&quot;] &gt; 4000, 
                                  casas[&quot;SalePrice&quot;] &lt; 300000)

# Scatterplot

fig, ax = plt.subplots(1, 2, figsize=(12,4))
sns.scatterplot(x=&quot;GrLivArea&quot;, y=&quot;SalePrice&quot;, hue=&quot;outlier&quot;, data=casas, ax = ax[0])</code></pre>
<pre><code>## &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a28d505c0&gt;</code></pre>
<pre class="python"><code>plt.title(&quot;Dos propiedades baratas para su tamaño&quot;, fontsize = 16)</code></pre>
<pre><code>## Text(0.5, 1.0, &#39;Dos propiedades baratas para su tamaño&#39;)</code></pre>
<pre class="python"><code>ax[1].set(xscale=&quot;log&quot;, yscale=&quot;log&quot;)</code></pre>
<pre><code>## [None, None]</code></pre>
<pre class="python"><code>ax[1].set_xlabel(&quot;log&quot;) #, ylabel = &quot;log&quot;)</code></pre>
<pre><code>## Text(0.5, 0, &#39;log&#39;)</code></pre>
<pre class="python"><code>sns.scatterplot(x=&quot;GrLivArea&quot;, y=&quot;SalePrice&quot;, hue=&quot;outlier&quot;, data=casas, ax = ax[1])</code></pre>
<pre><code>## &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a299c5f28&gt;</code></pre>
<pre class="python"><code>_ = plt.title(&quot;Transformación logarítmica&quot;, fontsize = 16)
</code></pre>
<p><img src="/posts/2019-06-16-prediciendo-precios-propiedades_files/figure-html/unnamed-chunk-10-1.png" width="1152" /></p>
</div>
<div id="variables-numericas-discontinuas" class="section level2">
<h2>Variables numéricas discontinuas</h2>
<p>Estas variables son numéricas pero representan cuentas (cantidad de baños, cantidad de cuartos, etc.).</p>
<pre class="python"><code># Cantidad de baños, cantidad de garages
cuentas =   [&quot;KitchenAbvGr&quot;, &quot;BedroomAbvGr&quot;, 
             &quot;Fireplaces&quot;,   &quot;BsmtFullBath&quot;,
             &quot;TotRmsAbvGrd&quot;, &quot;FullBath&quot;,
             &quot;HalfBath&quot;,     &quot;YearBuilt&quot;]   

# Panel de (2, 3)
dim_panel = (2, 4)
fig, ax = plt.subplots(dim_panel[0], dim_panel[1], figsize=(12,8))
ax[1,3].tick_params(labelbottom = False)
fig.subplots_adjust(hspace=0.4, wspace=0.4)

# Ordenar los nombres de las columnas (2, 3) para iterar fácil
cols = np.reshape(np.array(cuentas)[:8], dim_panel) # tomo los primeros 6 para que entre en el panel
            
_ = [sns.countplot(x=cols[i, j], data=casas, ax = ax[i, j]) for i in range(dim_panel[0]) 
                                                              for j in range(dim_panel[1])]
        </code></pre>
</div>
<div id="variables-categoricas" class="section level2">
<h2>Variables categóricas</h2>
<p>Estas variables son categorías y las modelamos como <em>dummies</em>.</p>
<pre class="python"><code>categoricas = [&quot;LotShape&quot;,     &quot;LandContour&quot;,   &quot;BldgType&quot;,   &quot;Foundation&quot;,
               &quot;Neighborhood&quot;, &quot;Exterior1st&quot;,   &quot;LandSlope&quot;,  &quot;HouseStyle&quot;,  
               &quot;PavedDrive&quot;,   &quot;SaleCondition&quot;, &quot;RoofStyle&quot;,  &quot;CentralAir&quot;,     
               &quot;LotShape&quot;,     &quot;LandContour&quot;,   &quot;MSZoning&quot;,   &quot;SaleType&quot;,
               &quot;Street&quot;,       &quot;Utilities&quot;,     &quot;Heating&quot;,    &quot;RoofMatl&quot;,
               &quot;Exterior2nd&quot;,  &quot;LotConfig&quot;,                                     
               &quot;Alley&quot;,        &quot;Electrical&quot;,   &quot;BsmtFinType1&quot;, &quot;BsmtFinType2&quot;,  # Tienen Nan
               &quot;GarageType&quot;,   &quot;MiscFeature&quot;,   &quot;MasVnrType&quot;,  &quot;Fence&quot;          # Tienen Nan
              ]




dim_panel = (5, 5)
fig, ax = plt.subplots(dim_panel[0], dim_panel[1], figsize=(12,16))

# Apagar los tick labels cuando son demasiados
apagar_ejes = [
    (0, 2), (0, 3), (0, 4), 
    (1, 0), (1, 2), (1, 4), 
    (2, 0), (2, 2), (2, 3),
    (3, 0), (3, 3), (3, 4),
    (4, 0), (4, 1), (4, 3), (4, 4)
]

_ = [ax[plt].tick_params(labelbottom = False) for plt in apagar_ejes]

# Fijar los espacios entre los subplots
fig.subplots_adjust(hspace=0.4, wspace=0.6)

cols = np.reshape(np.array(categoricas)[:25], dim_panel)
_ = [sns.countplot(x=cols[i, j], data=casas, ax = ax[i, j]) for i in range(dim_panel[0]) 
                                                              for j in range(dim_panel[1])]</code></pre>
<p><code>Street</code>, <code>Utilities</code>, <code>Heating</code> y <code>RoofMatl</code> tienen muy poca variación y pueden generar problemas en el modelo.</p>
<pre class="python"><code># Sacar las problematicas
cat_problemas = [&quot;Street&quot;, &quot;Utilities&quot;, &quot;Heating&quot;, &quot;RoofMatl&quot;] 

#_ = [ categoricas.remove(col) for col in cat_problemas  ]


cat_missing = [&quot;MasVnrType&quot;,   &quot;GarageType&quot;,  
               #&quot;Electrical&quot;,   &quot;MiscFeature&quot;,
               &quot;BsmtFinType1&quot;, &quot;BsmtFinType2&quot;,
               &quot;LotConfig&quot;,    &quot;Exterior2nd&quot;,  &quot;LandSlope&quot;, 
               &quot;Alley&quot;,        &quot;Fence&quot; ]

_ = [ categoricas.remove(col) for col in cat_missing  ]</code></pre>
</div>
<div id="variables-categoricas-ordinales" class="section level2">
<h2>Variables Categóricas Ordinales</h2>
<p>El último tipo de columna son las variables categóricas ordinales (ej: calidad de la piscina). En estos casos, la variable aparece como texto, pero en realidad queremos modelarla como numérica, porque Calidad = 2 es más que Calidad = 1. Para eso tenemos que recodificar las columnas.</p>
<pre class="python"><code>ordinales = [&quot;OverallQual&quot;,  &quot;OverallCond&quot;, &quot;ExterQual&quot;,
             &quot;ExterCond&quot;,    &quot;BsmtQual&quot;,    &quot;BsmtCond&quot;,
             &quot;BsmtExposure&quot;, &quot;HeatingQC&quot;,   &quot;KitchenQual&quot;,
             &quot;Functional&quot;,   &quot;FireplaceQu&quot;, &quot;PoolQC&quot;,
             &quot;GarageFinish&quot;, &quot;GarageCond&quot;,  &quot;GarageQual&quot;,
             &quot;Fence&quot;] </code></pre>
<p>Llevamos las que tienen escalas de calidad (Ex, Gd, Fa, Po) a una escala común. Por ejemplo,cuando es <em>missing</em> la dejamos en 0. Si la calidad de la piscina es missing, es porque la propiedad no tiene piscina y está bien que quede en 0.</p>
<pre class="python"><code>def cambiar_escala(df, col, escala):
  print(f&#39;\n{col}\n&#39;)
  print(casas[col].value_counts(dropna = False))
  # reemplazar missings
  casas[col].fillna(&quot;MISSING&quot;, inplace = True)
  # aplicar escala_ordinal
  casas[col].replace(escala, inplace = True)
  print(casas[col].value_counts(dropna = False))
  print(&quot;-&quot; * 20)</code></pre>
<pre class="python"><code># Po &lt; Fa &lt; TA &lt; Gd &lt; Ex
ESCALA_ORDINAL = { &quot;MISSING&quot;: 0, &quot;Po&quot; : 1, &quot;Fa&quot; : 2, 
                   &quot;TA&quot; : 3,     &quot;Gd&quot; : 4, &quot;Ex&quot; : 5}

ordinales_escala_comun = [ &quot;ExterQual&quot;,   &quot;ExterCond&quot;,   
                           &quot;BsmtQual&quot;,    &quot;BsmtCond&quot;,     
                           &quot;HeatingQC&quot;,   &quot;KitchenQual&quot;,  
                           &quot;FireplaceQu&quot;, &quot;PoolQC&quot;,       
                           &quot;GarageCond&quot;  ]

# cambiar casas inplace
_ = [ cambiar_escala(casas, col, ESCALA_ORDINAL) for col in ordinales_escala_comun]</code></pre>
<pre><code>## 
## ExterQual
## 
## TA    906
## Gd    488
## Ex     52
## Fa     14
## Name: ExterQual, dtype: int64
## 3    906
## 4    488
## 5     52
## 2     14
## Name: ExterQual, dtype: int64
## --------------------
## 
## ExterCond
## 
## TA    1282
## Gd     146
## Fa      28
## Ex       3
## Po       1
## Name: ExterCond, dtype: int64
## 3    1282
## 4     146
## 2      28
## 5       3
## 1       1
## Name: ExterCond, dtype: int64
## --------------------
## 
## BsmtQual
## 
## TA     649
## Gd     618
## Ex     121
## NaN     37
## Fa      35
## Name: BsmtQual, dtype: int64
## 3    649
## 4    618
## 5    121
## 0     37
## 2     35
## Name: BsmtQual, dtype: int64
## --------------------
## 
## BsmtCond
## 
## TA     1311
## Gd       65
## Fa       45
## NaN      37
## Po        2
## Name: BsmtCond, dtype: int64
## 3    1311
## 4      65
## 2      45
## 0      37
## 1       2
## Name: BsmtCond, dtype: int64
## --------------------
## 
## HeatingQC
## 
## Ex    741
## TA    428
## Gd    241
## Fa     49
## Po      1
## Name: HeatingQC, dtype: int64
## 5    741
## 3    428
## 4    241
## 2     49
## 1      1
## Name: HeatingQC, dtype: int64
## --------------------
## 
## KitchenQual
## 
## TA    735
## Gd    586
## Ex    100
## Fa     39
## Name: KitchenQual, dtype: int64
## 3    735
## 4    586
## 5    100
## 2     39
## Name: KitchenQual, dtype: int64
## --------------------
## 
## FireplaceQu
## 
## NaN    690
## Gd     380
## TA     313
## Fa      33
## Ex      24
## Po      20
## Name: FireplaceQu, dtype: int64
## 0    690
## 4    380
## 3    313
## 2     33
## 5     24
## 1     20
## Name: FireplaceQu, dtype: int64
## --------------------
## 
## PoolQC
## 
## NaN    1453
## Gd        3
## Fa        2
## Ex        2
## Name: PoolQC, dtype: int64
## 0    1453
## 4       3
## 5       2
## 2       2
## Name: PoolQC, dtype: int64
## --------------------
## 
## GarageCond
## 
## TA     1326
## NaN      81
## Fa       35
## Gd        9
## Po        7
## Ex        2
## Name: GarageCond, dtype: int64
## 3    1326
## 0      81
## 2      35
## 4       9
## 1       7
## 5       2
## Name: GarageCond, dtype: int64
## --------------------</code></pre>
<pre class="python"><code>ESCALA_FUNCTIONAL = { &quot;Sal&quot; : 0, &quot;Sev&quot; : 1,
                      &quot;Maj2&quot;: 2, &quot;Maj1&quot;: 3,
                      &quot;Mod&quot; : 4, &quot;Min2&quot;: 5,
                      &quot;Min1&quot;: 6, &quot;Typ&quot;: 7
                    }

cambiar_escala(casas, &quot;Functional&quot;, escala = ESCALA_FUNCTIONAL)</code></pre>
<pre><code>## 
## Functional
## 
## Typ     1360
## Min2      34
## Min1      31
## Mod       15
## Maj1      14
## Maj2       5
## Sev        1
## Name: Functional, dtype: int64
## 7    1360
## 5      34
## 6      31
## 4      15
## 3      14
## 2       5
## 1       1
## Name: Functional, dtype: int64
## --------------------</code></pre>
</div>
</div>
